//
// DO NOT MODIFY THIS FILE
//
// THIS FILE IS AUTOMATICALLY GENERATED IN ITS ENTIRETY
// ANY CHANGES MADE IN THIS FILE WILL BE OVERWRITTEN WITHOUT WARNING
// WHENEVER THE LEXER / PROCESSOR IS INVOKED.
//

#include "parser_errors.h"

#include "out.h"

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

uint16_t CallFunction(uint8_t func_xlat, ParamUnion params[]) {
	switch (func_xlat) {
		case 0:
			ShowBlocks();
			break;
		case 1:
			ShowSystem();
			break;
		case 3:
			ShowBlockByCategory(params[0].param_uint16_t);
			break;
		case 4:
			ShowBlockCatN(params[0].param_uint16_t, params[1].param_int16_t);
			break;
		case 2:
			ShowBlockByLabel(params[0].param_char_star);
			break;
		case 5:
			ShowBlockByID(params[0].param_int16_t);
			break;
		case 6:
			MessagesMute();
			break;
		case 7:
			MessagesUnmute();
			break;
		case 8:
			MonitorStart();
			break;
		case 9:
			MonitorStop();
			break;
		case 10:
			MonitorRemoveByLabel(params[0].param_char_star);
			break;
		case 11:
			MonitorRemoveByBlockCatN(params[0].param_uint16_t, params[1].param_int16_t);
			break;
		case 12:
			MonitorByLabel(params[0].param_char_star);
			break;
		case 13:
			MonitorByBlockCatN(params[0].param_uint16_t, params[1].param_int16_t);
			break;
		case 14:
			ClearBlockByLabel(params[0].param_char_star);
			break;
		case 15:
			ClearBlockByBlockCatN(params[0].param_uint16_t, params[1].param_int16_t);
			break;
		case 16:
			SendCommandToBlockCatN(params[0].param_uint16_t, params[1].param_int16_t, params[2].param_uint16_t);
			break;
		case 17:
			SendCommandToBlockLabel(params[0].param_char_star, params[1].param_uint16_t);
			break;
		case 18:
			SimIntDataMessageFromBCatN(params[0].param_uint16_t, params[1].param_int16_t, params[2].param_int16_t);
			break;
		case 19:
			SimFloatDataMessageFromBCatN(params[0].param_uint16_t, params[1].param_int16_t, params[2].param_float);
			break;
		case 20:
			SimIntDataMessageFromBlockLabel(params[0].param_char_star, params[1].param_int16_t);
			break;
		case 21:
			SimFloatDataMessageFromBlockLabel(params[0].param_char_star, params[1].param_float);
			break;
		case 22:
			DebugOn();
			break;
		case 23:
			DebugOff();
			break;
		case 24:
			DebugTermOn();
			break;
		case 25:
			DebugTermOff();
			break;
		case 26:
			DebugSetLevel(params[0].param_int16_t);
			break;
		case 27:
			ShowTime();
			break;
		case 28:
			SetTime(params[0].param_char_star);
			break;
		case 29:
			ShowDate();
			break;
		case 30:
			SetDate(params[0].param_char_star);
			break;
		case 31:
			ConfClearBlocks();
			break;
		case 32:
			ConfClearAll();
			break;
		case 33:
			ConfReadDefaultFile();
			break;
		case 34:
			ConfReadFilename(params[0].param_char_star);
			break;
		case 35:
			WriteToDefaultConfigFile();
			break;
		case 36:
			WriteEmptyDefaultConfigFile();
			break;
		case 37:
			WriteToFilenameConfigFile(params[0].param_char_star);
			break;
		case 38:
			CopyConfigFileToFile(params[0].param_char_star, params[1].param_char_star);
			break;
		case 39:
			BlockDisableByBlockCatN(params[0].param_uint16_t, params[1].param_int16_t);
			break;
		case 40:
			BlockDisableByLabel(params[0].param_char_star);
			break;
		case 41:
			BlockEnableByBlockCatN(params[0].param_uint16_t, params[1].param_int16_t);
			break;
		case 42:
			BlockEnableByLabel(params[0].param_char_star);
			break;
		case 43:
			BlockDeleteByBlockCatN(params[0].param_uint16_t, params[1].param_int16_t);
			break;
		case 44:
			BlockDeleteByLabel(params[0].param_char_star);
			break;
		case 45:
			BlockRename(params[0].param_char_star, params[1].param_char_star);
			break;
		case 46:
			TerminalExit();
			break;
		case 47:
			TerminalLogout();
			break;
		case 48:
			SystemReboot();
			break;
		default:
			return PE_FUNC_XLAT_NOT_MATCHED_IN_CALLFUNCTION;
			break;
	}
	return PEME_NO_ERROR;
}

//TODO: Command Line Options Processing
//TODO: AST Validation Walk - 
//TODO: AST Flag end points
//TODO: AST Order Ambiguity Report
//TODO: AST Determine Partial Keyword Uniqueness
//TODO: AST Warn unused IDs, lookups, params
//TODO: Parser/AST output Action prototypes
//TODO: Configuration Grammar with %section directive
//TODO: Context change on <identifier> value

uint16_t LookupIdentMap (char* key) {
	uint16_t count;
	uint16_t idx = 0;
	count = sizeof(ident_map) / sizeof(XLATMap);
	while (idx < count) {
		if(strcasecmp(ident_map[idx].label, key) == 0) {
			return ident_map[idx].xlat_id;
		}
		idx++;
	}
	return -1;
}

uint16_t LookupLookupMap (char* key) {
	uint16_t count;
	uint16_t idx = 0;
	count = sizeof(lookup_map) / sizeof(XLATMap);
	while (idx < count) {
		if(strcasecmp(lookup_map[idx].label, key) == 0) {
			return lookup_map[idx].xlat_id;
		}
		idx++;
	}
	return -1;
}

uint16_t LookupFuncMap (char* key) {
	uint16_t count;
	uint16_t idx = 0;
	count = sizeof(func_map) / sizeof(XLATMap);
	while (idx < count) {
		if(strcasecmp(func_map[idx].label, key) == 0) {
			return func_map[idx].xlat_id;
		}
		idx++;
	}
	return -1;
}

uint16_t LookupIdentifierMembers(uint16_t ident_xlat, char* lookup_string) {
	uint16_t count;
	uint16_t idx = 0;
	switch(ident_xlat) {
		case 0: {
			count = sizeof(block_cat_defs) / sizeof(SimpleStringArray);
			while (idx < count) {
				if(strcasecmp(block_cat_defs[idx].text, lookup_string) == 0) {
					return idx;
				}
				idx++;
			}
		}
			break;
		case 1: {
			count = sizeof(command_strings) / sizeof(SimpleStringArray);
			while (idx < count) {
				if(strcasecmp(command_strings[idx].text, lookup_string) == 0) {
					return idx;
				}
				idx++;
			}
		}
			break;
		default:
		return 0;
	}
	return 0;
}

