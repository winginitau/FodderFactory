void CallFunction(uint8_t func_xlat, ParamUnion params[]) {

	switch (func_xlat) {
		case 3:
//			char** ShowBlockByCategory(int block_category);
			ShowBlockByCategory(params[0].param_int16);
			break;
		case 4:
//			char** ShowBlockCatN(int block_category, int param1_int);
			ShowBlockCatN(params[0].param_int16, params[1].param_int16);
			break;
		default:
			// XXX
			printf("ERROR, No matched func_xlat in CallFunction - not matching function?\n\r");
			exit(-1);
	}
}



// Lookup template for idents in an XLAT array

uint16_t LookupIdentMap (char* key) {
	uint16_t count;
	uint16_t idx = 0;
	count = sizeof(ident_map) / sizeof(XLATMap);
	while (idx < count) {
		if(strcmp(#map_instance#[idx].label, key)) {
			return #map_instance#[idx].xlat_id;
		}
		idx++;
	}
}

uint16_t LookupIdentifierMembers(uint16_t ident_xlat, char* lookup_string) {
	uint16_t count;
	uint16_t idx = 0;
	switch (ident_xlat) {
		case 0: {
			count = sizeof(block_cat_defs) / sizeof(SimpleStringArray);
			while (idx < count) {
				if (strcmp(block_cat_defs[idx].text, lookup_string)) {
					return idx;
				}
				idx++;
			}
		}
			break;
		case 1: {
			count = sizeof(command_strings) / sizeof(SimpleStringArray);
			while (idx < count) {
				if (strcmp(command_strings[idx].text, lookup_string)) {
					return idx;
				}
				idx++;
			}
		}
			break;
		default:
			return 0;
	}
}


return block_cat (enum)
return command (enun)


void ShowBlockCatN(int block_category, int param1_int) {
	// >>>
	// >>> INSERT CODE HERE TO CARRY OUT THE DESIRED ACTION
	// >>>
	char temp[MAX_BUFFER_LENGTH];
	sprintf(temp, "ShowBlockCatN(int block_category, int param1_int) with params %d %d\n\r", block_category, param1_int);
	// >>>
	// >>> AND SEND THE RESULTS OUT VIA CALLS TO ICLIWriteLine
	// >>>
	ICLIWriteLine(temp);
}





#ifdef USE_PROGMEM
uint8_t BlockTypeStringArrayIndex(const char* key) {
	SimpleStringArray temp;
	for (int i = 0; i < LAST_BLOCK_TYPE; i++) {
		memcpy_P (&temp, &block_type_strings[i], sizeof temp);
		if (strcmp(key, temp.text) == 0) {
			return i;
		}
	}
	return UINT8_INIT;
}

#else
uint8_t BlockTypeStringArrayIndex(const char* key) {
	//
	for (int i = 0; i < LAST_BLOCK_TYPE; i++) {
		if (strcmp(key, block_type_strings[i].text) == 0) {
			return i;
		}
	}
	return UINT8_INIT;
}
#endif


//
// DO NOT MODIFY THIS FILE
//
// THIS FILE IS AUTOMATICALLY GENERATED IN ITS ENTIRETY
// ANY CHANGES MADE IN THIS FILE WILL BE OVERWRITTEN WITHOUT WARNING
// WHENEVER THE LEXER / PROCESSOR IS INVOKED.
//

#ifndef OUT_H_
#define OUT_H_


#include "common_config.h"
//#include "ff_sys_config.h"
//#include "/home/brendan/git/FodderFactory/ff_config_icli/ICLI.h"
#include <stdint.h>
#include <string.h>


//
// Struct typedefs used by the parser 
// 

typedef struct SIMPLE_STRING_ARRAY_TYPE {
    // Array of strings relating to enums
    // Inside this struct, extended intitaliser lists are ok
    const char* text;
} SimpleStringArray;


typedef struct AST_ARRAY {
    uint16_t id;
    int type;
    char label[MAX_LABEL_LENGTH];
    bool action;
    uint16_t parent;
    uint16_t first_child;
    uint16_t next_sibling;
    char action_identifier[MAX_LABEL_LENGTH];
} ASTA;


typedef struct XLAT_MAP {
	char label[MAX_LABEL_LENGTH];
	uint16_t xlat_id;
} XLATMap;

enum {
	FF_ERROR_CAT = 0,
	FF_GENERIC_BLOCK,
	FF_SYSTEM,
	FF_INPUT,
	FF_MONITOR,
	FF_SCHEDULE,
	FF_RULE,
	FF_CONTROLLER,
	FF_OUTPUT,
	LAST_BLOCK_CAT,
};

#ifdef USE_PROGMEM
static const SimpleStringArray block_cat_defs [LAST_BLOCK_CAT] PROGMEM = {
#else
static const SimpleStringArray block_cat_defs [LAST_BLOCK_CAT] = {
#endif
	"ERROR_CAT",
	"GENERIC",
	"SYSTEM",
	"INPUT",
	"MONITOR",
	"SCHEDULE",
	"RULE",
	"CONROLLER",
	"OUTPUT",
};

enum {
	CMD_ERROR = 0,
	CMD_OUTPUT_OFF,
	CMD_OUTPUT_ON,
	CMD_RESET_MIN_MAX,
	LAST_COMMAND,
};

#ifdef USE_PROGMEM
static const SimpleStringArray command_strings [LAST_COMMAND] PROGMEM = {
#else
static const SimpleStringArray command_strings [LAST_COMMAND] = {
#endif
	"CMD_ERROR",
	"CMD_OUTPUT_OFF",
	"CMD_OUTPUT_ON",
	"CMD_RESET_MIN_MAX",
};

char** ShowBlockByCategory(int block_category);

char** ShowBlockCatN(int block_category, int param1_int);

char** ShowBlockByLabel(char* block_label);

char** ShowBlockByID(int param1_int);

char** MonitorRemoveByLabel(char* block_label);

char** MonitorRemoveByBlockCatN(int block_category, int param1_int);

char** MonitorByLabel(char* block_label);

char** MonitorByBlockCatN(int block_category, int param1_int);

char** ClearBlockByLabel(char* block_label);

char** ClearBlockByBlockCatN(int block_category, int param1_int);

char** SendCommandToBlockCatN(int block_category, int param1_int, int command);

char** SendCommandToBlockLabel(char* block_label, int command);

char** SimIntDataMessageFromBCatN(int block_category, int param1_int, int param2_int);

char** SimFloatDataMessageFromBCatN(int block_category, int param1_int, float param2_float);

char** SimIntDataMessageFromBlockLabel(char* block_label, int param2_int);

char** SimFloatDataMessageFromBlockLabel(char* block_label, float param2_float);

char** DebugSetLevel(int param1_int);

char** SetTime(char* param1_time);

char** SetDate(char* param1_date);

char** ConfReadFilename(char* param1_string);

char** WriteToFilenameConfigFile(char* param1_string);

char** CopyConfigFileToFile(char* param1_string, char* param2_string);

char** BlockDisableByBlockCatN(int block_category, int param1_int);

char** BlockDisableByLabel(char* param1_string);

char** BlockEnableByBlockCatN(int block_category, int param1_int);

char** BlockEnableByLabel(char* block_label);

char** BlockDeleteByBlockCatN(int block_category, int param1_int);

char** BlockDeleteByLabel(char* param1_string);

char** BlockRename(char* param1_string, char* param2_string);

#ifdef USE_PROGMEM
static const ASTA asta [88] PROGMEM = {
#else
static const ASTA asta [88] = {
#endif
	1, 1, "SHOW", 0, 0, 2, 8, "",
	2, 1, "BLOCKS", 1, 1, 0, 3, "SHOW_BLOCKS",
	3, 1, "SYSTEM", 1, 1, 0, 4, "SHOW_SYSTEM",
	4, 2, "block_cat_defs", 1, 1, 5, 6, "SHOW_BLOCK_CATEGORY",
	5, 6, "param-integer", 1, 4, 0, 0, "SHOW_BLOCK_CAT_N",
	6, 3, "block_label", 1, 1, 0, 7, "SHOW_BLOCK_LABEL",
	7, 6, "param-integer", 1, 1, 0, 0, "SHOW_BLOCK_ID",
	8, 1, "MUTE", 0, 0, 9, 12, "",
	9, 1, "MESSAGES", 0, 8, 10, 0, "",
	10, 1, "ON", 1, 9, 0, 11, "MUTE_MESSAGES_ON",
	11, 1, "OFF", 1, 9, 0, 0, "MUTE_MESSAGES_OFF",
	12, 1, "MONITOR", 0, 0, 13, 22, "",
	13, 1, "START", 1, 12, 0, 14, "MONIOTR_START",
	14, 1, "STOP", 0, 12, 15, 19, "",
	15, 1, "ALL", 1, 14, 0, 16, "MONITOR_STOP_ALL",
	16, 3, "block_label", 1, 14, 0, 17, "MONITOR_STOP_BLOCK_LABEL",
	17, 2, "block_cat_defs", 0, 14, 18, 0, "",
	18, 6, "param-integer", 1, 17, 0, 0, "MONITOR_STOP_BLOCK_CAT_N",
	19, 3, "block_label", 1, 12, 0, 20, "MONITOR_BLOCK_LABEL",
	20, 2, "block_cat_defs", 0, 12, 21, 0, "",
	21, 6, "param-integer", 1, 20, 0, 0, "MONITOR_BLOCK_CAT_N",
	22, 1, "CLEAR", 0, 0, 23, 26, "",
	23, 3, "block_label", 1, 22, 0, 24, "CLEAR_BLOCK_LABEL",
	24, 2, "block_cat_defs", 0, 22, 25, 0, "",
	25, 6, "param-integer", 1, 24, 0, 0, "CLEAR_BLOCK_CAT_N",
	26, 1, "MESSAGE", 0, 0, 27, 45, "",
	27, 1, "COMMAND", 0, 26, 28, 33, "",
	28, 2, "block_cat_defs", 0, 27, 29, 31, "",
	29, 6, "param-integer", 0, 28, 30, 0, "",
	30, 2, "command_strings", 1, 29, 0, 0, "COMMAND_BLOCK_CAT_N",
	31, 3, "block_label", 0, 27, 32, 0, "",
	32, 2, "command_strings", 1, 31, 0, 0, "COMMAND_BLOCK_LABEL",
	33, 1, "DATA", 0, 26, 34, 0, "",
	34, 2, "block_cat_defs", 0, 33, 35, 40, "",
	35, 6, "param-integer", 0, 34, 36, 0, "",
	36, 1, "INT", 0, 35, 37, 38, "",
	37, 6, "param-integer", 1, 36, 0, 0, "MESSAGE_DATA_BCAT_N_INT",
	38, 1, "FLOAT", 0, 35, 39, 0, "",
	39, 7, "param-float", 1, 38, 0, 0, "MESSAGE_DATA_BCAT_N_FLOAT",
	40, 3, "block_label", 0, 33, 41, 0, "",
	41, 1, "INT", 0, 40, 42, 43, "",
	42, 6, "param-integer", 1, 41, 0, 0, "MESSAGE_DATA_LABEL_INT",
	43, 1, "FLOAT", 0, 40, 44, 0, "",
	44, 7, "param-float", 1, 43, 0, 0, "MESSAGE_DATA_LABEL_FLOAT",
	45, 1, "DEBUG", 0, 0, 46, 53, "",
	46, 1, "ON", 1, 45, 0, 47, "DEBUG_ON",
	47, 1, "OFF", 1, 45, 0, 48, "DEBUG_OFF",
	48, 1, "TERMINAL", 0, 45, 49, 51, "",
	49, 1, "ON", 1, 48, 0, 50, "DEBUG_TERMINAL_ON",
	50, 1, "OFF", 1, 48, 0, 0, "DEBUG_TERMINAL_OFF",
	51, 1, "LEVEL", 0, 45, 52, 0, "",
	52, 6, "param-integer", 1, 51, 0, 0, "DEBUG_LEVEL",
	53, 1, "CLOCK", 1, 0, 54, 56, "SHOW_TIME",
	54, 1, "SET", 0, 53, 55, 0, "",
	55, 5, "param-time", 1, 54, 0, 0, "SET_TIME",
	56, 1, "DATE", 1, 0, 57, 59, "SHOW_DATE",
	57, 1, "SET", 0, 56, 58, 0, "",
	58, 4, "param-date", 1, 57, 0, 0, "SET_DATE",
	59, 1, "CONFIGURE", 0, 0, 60, 65, "",
	60, 1, "CLEAR", 0, 59, 61, 63, "",
	61, 1, "BLOCKS", 1, 60, 0, 62, "CONF_CLEAR_BLOCKS",
	62, 1, "ALL", 1, 60, 0, 0, "CONF_CLEAR_ALL",
	63, 1, "FILE", 1, 59, 64, 0, "CONF_FILE_DEFAULT",
	64, 8, "param-string", 1, 63, 0, 0, "CONF_FILE_FILENAME",
	65, 1, "WRITE", 1, 0, 66, 68, "WRITE_DEFAULT",
	66, 1, "INIT", 1, 65, 0, 67, "WRITE_INIT",
	67, 8, "param-string", 1, 65, 0, 0, "WRITE_FILENAME",
	68, 1, "COPY", 0, 0, 69, 71, "",
	69, 8, "param-string", 0, 68, 70, 0, "",
	70, 8, "param-string", 1, 69, 0, 0, "COPY_FILE_FILE",
	71, 1, "DISABLE", 0, 0, 72, 75, "",
	72, 2, "block_cat_defs", 0, 71, 73, 74, "",
	73, 6, "param-integer", 1, 72, 0, 0, "DISABLE_BLOCK_CAT_N",
	74, 8, "param-string", 1, 71, 0, 0, "DISABLE_BLOCK_LABEL",
	75, 1, "ENABLE", 0, 0, 76, 79, "",
	76, 2, "block_cat_defs", 0, 75, 77, 78, "",
	77, 6, "param-integer", 1, 76, 0, 0, "ENABLE_BLOCK_CAT_N",
	78, 3, "block_label", 1, 75, 0, 0, "ENABLE_BLOCK_LABEL",
	79, 1, "DELETE", 0, 0, 80, 83, "",
	80, 2, "block_cat_defs", 0, 79, 81, 82, "",
	81, 6, "param-integer", 1, 80, 0, 0, "DELETE_BLOCK_CAT_N",
	82, 8, "param-string", 1, 79, 0, 0, "DELETE_BLOCK_LABEL",
	83, 1, "RENAME", 0, 0, 84, 86, "",
	84, 8, "param-string", 0, 83, 85, 0, "",
	85, 8, "param-string", 1, 84, 0, 0, "RENAME_BLOCK",
	86, 1, "EXIT", 1, 0, 0, 87, "EXIT",
	87, 1, "LOGOUT", 1, 0, 0, 88, "LOGOUT",
	88, 1, "REBOOT", 1, 0, 0, 0, "REBOOT",
};

#ifdef USE_PROGMEM
static const XLATMap ident_map [2] PROGMEM = {
#else
static const XLATMap ident_map [2] = {
#endif
	"block_cat_defs", 0,
	"command_strings", 1,
};

#ifdef USE_PROGMEM
static const XLATMap lookup_map [1] PROGMEM = {
#else
static const XLATMap lookup_map [1] = {
#endif
	"LookupBlockLabel", 0,
};

#ifdef USE_PROGMEM
static const XLATMap func_map [49] PROGMEM = {
#else
static const XLATMap func_map [49] = {
#endif
	"SHOW_BLOCKS", 0,
	"SHOW_SYSTEM", 1,
	"SHOW_BLOCK_LABEL", 2,
	"SHOW_BLOCK_CATEGORY", 3,
	"SHOW_BLOCK_CAT_N", 4,
	"SHOW_BLOCK_ID", 5,
	"MUTE_MESSAGES_ON", 6,
	"MUTE_MESSAGES_OFF", 7,
	"MONIOTR_START", 8,
	"MONITOR_STOP_ALL", 9,
	"MONITOR_STOP_BLOCK_LABEL", 10,
	"MONITOR_STOP_BLOCK_CAT_N", 11,
	"MONITOR_BLOCK_LABEL", 12,
	"MONITOR_BLOCK_CAT_N", 13,
	"CLEAR_BLOCK_LABEL", 14,
	"CLEAR_BLOCK_CAT_N", 15,
	"COMMAND_BLOCK_CAT_N", 16,
	"COMMAND_BLOCK_LABEL", 17,
	"MESSAGE_DATA_BCAT_N_INT", 18,
	"MESSAGE_DATA_BCAT_N_FLOAT", 19,
	"MESSAGE_DATA_LABEL_INT", 20,
	"MESSAGE_DATA_LABEL_FLOAT", 21,
	"DEBUG_ON", 22,
	"DEBUG_OFF", 23,
	"DEBUG_TERMINAL_ON", 24,
	"DEBUG_TERMINAL_OFF", 25,
	"DEBUG_LEVEL", 26,
	"SHOW_TIME", 27,
	"SET_TIME", 28,
	"SHOW_DATE", 29,
	"SET_DATE", 30,
	"CONF_CLEAR_BLOCKS", 31,
	"CONF_CLEAR_ALL", 32,
	"CONF_FILE_DEFAULT", 33,
	"CONF_FILE_FILENAME", 34,
	"WRITE_DEFAULT", 35,
	"WRITE_INIT", 36,
	"WRITE_FILENAME", 37,
	"COPY_FILE_FILE", 38,
	"DISABLE_BLOCK_CAT_N", 39,
	"DISABLE_BLOCK_LABEL", 40,
	"ENABLE_BLOCK_CAT_N", 41,
	"ENABLE_BLOCK_LABEL", 42,
	"DELETE_BLOCK_CAT_N", 43,
	"DELETE_BLOCK_LABEL", 44,
	"RENAME_BLOCK", 45,
	"EXIT", 46,
	"LOGOUT", 47,
	"REBOOT", 48,
};

uint16_t LookupIdentMap (char* key);
uint16_t LookupLookupMap (char* key);
uint16_t LookupFuncMap (char* key);
uint16_t LookupIdentifierMembers(uint16_t ident_xlat, char* lookup_string);

#endif /* OUT_H_ */

//
// DO NOT MODIFY THIS FILE
//
// THIS FILE IS AUTOMATICALLY GENERATED IN ITS ENTIRETY
// ANY CHANGES MADE IN THIS FILE WILL BE OVERWRITTEN WITHOUT WARNING
// WHENEVER THE LEXER / PROCESSOR IS INVOKED.
//

#include "out.h"	

//TODO: Command Line Options Processing
//TODO: AST Validation Walk - 
//TODO: AST Flag end points
//TODO: AST Order Ambiguity Report
//TODO: AST Determine Partial Keyword Uniqueness
//TODO: AST Warn unused IDs, lookups, params
//TODO: Parser/AST output Action prototypes
//TODO: Configuration Grammar with %section directive
//TODO: Context change on <identifier> value

uint16_t LookupIdentMap (char* key) {
	uint16_t count;
	uint16_t idx = 0;
	count = sizeof(ident_map) / sizeof(XLATMap);
	while (idx < count) {
		if(strcasecmp(ident_map[idx].label, key) == 0) {
			return ident_map[idx].xlat_id;
		}
		idx++;
	}
	return -1;
}

uint16_t LookupLookupMap (char* key) {
	uint16_t count;
	uint16_t idx = 0;
	count = sizeof(lookup_map) / sizeof(XLATMap);
	while (idx < count) {
		if(strcasecmp(lookup_map[idx].label, key) == 0) {
			return lookup_map[idx].xlat_id;
		}
		idx++;
	}
	return -1;
}

uint16_t LookupFuncMap (char* key) {
	uint16_t count;
	uint16_t idx = 0;
	count = sizeof(func_map) / sizeof(XLATMap);
	while (idx < count) {
		if(strcasecmp(func_map[idx].label, key) == 0) {
			return func_map[idx].xlat_id;
		}
		idx++;
	}
	return -1;
}

#include <stdio.h>

extern void ICLIWriteLine(char *str);

void ShowBlockByCategory(int block_category) {
	char temp[MAX_BUFFER_LENGTH];
	sprintf(temp, "ShowBlockByCategory(int block_category) with param %d\n\r", block_category);
	printf("%s", temp);

	ICLIWriteLine(temp);
}


void ShowBlockCatN(int block_category, int param1_int) {
	// >>>
	// >>> INSERT CODE HERE TO CARRY OUT THE DESIRED ACTION
	// >>>
	char temp[MAX_BUFFER_LENGTH];
	sprintf(temp, "ShowBlockCatN(int block_category, int param1_int) with params %d %d\n\r", block_category, param1_int);
	printf("%s", temp);
	// >>>
	// >>> AND SEND THE RESULTS OUT VIA CALLS TO ICLIWriteLine
	// >>>
	ICLIWriteLine(temp);
}

uint16_t LookupIdentifierMembers(uint16_t ident_xlat, char* lookup_string) {
	uint16_t count;
	uint16_t idx = 0;
	switch(ident_xlat) {
		case 0: {
			count = sizeof(block_cat_defs) / sizeof(SimpleStringArray);
			while (idx < count) {
				if(strcasecmp(block_cat_defs[idx].text, lookup_string) == 0) {
					return idx;
				}
				idx++;
			}
		}
			break;
		case 1: {
			count = sizeof(command_strings) / sizeof(SimpleStringArray);
			while (idx < count) {
				if(strcasecmp(command_strings[idx].text, lookup_string) == 0) {
					return idx;
				}
				idx++;
			}
		}
			break;
		default:
		return 0;
	}
	return 0;
}




